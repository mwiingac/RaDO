<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mind Map</title>
    <style>
        /* Style for the mind map */
/* Style for the mind map */
      #mindmap {
        width: 100%;
        height: 100vh;
      }

      .node circle {
        fill: #999;
        stroke: steelblue;
        stroke-width: 3px;
      }

      .node text {
        font: 12px sans-serif;
      }

      .link {
        fill: none;
        stroke: #555;
        stroke-width: 1.5px;
      }

      .node--internal circle {
        fill: lightsteelblue;
      }

      .node--leaf circle {
        fill: white;
      }

    </style>
</head>
<body>
    <div id="mindmap"></div>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>
        // JavaScript code to create the mind map
        // Data for the mind map
        const data = {
          name: "Matomo",
          children: [
              {
                  name: "Custom Events",
                  children: [
                      {
                          name: "Reporting",
                          children: [
                              { name: "Case 111068 - Customize Matomo to support reports" },
                              { name: "Case 111538 - Investigate how Matomo might track which report parameters are used" }
                          ]
                      },
                      {
                          name: "Search Pages",
                          children: [
                              { name: "Case 111069 - Customize Matomo to support filters, pagination, show more activity on REACT pages" },
                              { name: "Case 111587 - Customize Matomo to support sorting activity on BACKBONE pages" },
                              { name: "Case 111606 - Customize Matomo to support filter, show more, pagination activity on BACKBONE pages" },
                              { name: "Case 111616 - Customize Matomo to support column selector and sort activity on REACT pages" }
                          ]
                      },
                      {
                          name: "Other",
                          children: [
                              { name: "Case 111070 - Add customization so Matomo can analyze modal activity" }
                          ]
                      }
                  ]
              },
              {
                  name: "Rollout",
                  children: [
                      { name: "Case 104570 - Investigate adding Matomo to Base Platform" },
                      { name: "Case 108842 - Matomo User-level tracking opt-in" },
                      { name: "Case 110929 - Add out-of-the-box Matomo analytics to Platform" },
                      { name: "Case 110930 - Investigate using Matomo for/with MTT apps" },
                      { name: "Case 111180 - Investigate default configurable privacy settings for Matomo" },
                      { name: "Case 111670 - Reminder to create a resource that documents Matomo mapping e.g., what categories represent" },
                      { name: "Case 111918 - Matomo - remove numeric identifiers from tracked URLs" }
                  ]
              }
          ]
        };

        // Dimensions for the mind map
        const width = 960;
        const height = 600;

        // Create the SVG container for the mind map
        const svg = d3.select("#mindmap").append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(40,0)");

        // Create a tree layout
        const tree = d3.tree()
          .size([height, width - 160]);

        const root = d3.hierarchy(data);
        root.x0 = height / 2;
        root.y0 = 0;

        // Collapse all children initially
        root.children.forEach(collapse);

        update(root);

        // Function to collapse the node and its children
        function collapse(d) {
          if (d.children) {
              d._children = d.children;
              d._children.forEach(collapse);
              d.children = null;
          }
        }

        // Function to update the tree
        function update(source) {
          const nodes = root.descendants().reverse();
          const links = root.links();

          // Normalize for fixed-depth
          nodes.forEach(d => d.y = d.depth * 180);

          // Update the nodes…
          const node = svg.selectAll('g.node')
              .data(nodes, d => d.id || (d.id = ++i));

          // Enter any new nodes at the parent's previous position.
          const nodeEnter = node.enter().append('g')
              .attr('class', 'node')
              .attr('transform', d => `translate(${source.y0},${source.x0})`)
              .on('click', click);

          nodeEnter.append('circle')
              .attr('r', 1e-6)
              .attr('fill', d => d._children ? "lightsteelblue" : "#fff");

          nodeEnter.append('text')
              .attr('dy', '.35em')
              .attr('x', d => d._children ? -13 : 13)
              .attr('text-anchor', d => d._children ? 'end' : 'start')
              .text(d => d.data.name);

          // Transition nodes to their new position.
          const nodeUpdate = node.merge(nodeEnter).transition()
              .duration(750)
              .attr('transform', d => `translate(${d.y},${d.x})`);

          nodeUpdate.select('circle')
              .attr('r', 10)
              .attr('fill', d => d._children ? "lightsteelblue" : "#fff");

          nodeUpdate.select('text')
              .style('fill-opacity', 1);

          // Transition exiting nodes to the parent's new position.
          const nodeExit = node.exit().transition()
              .duration(750)
              .attr('transform', d => `translate(${source.y},${source.x})`)
              .remove();

          nodeExit.select('circle')
              .attr('r', 1e-6);

          nodeExit.select('text')
              .style('fill-opacity', 1e-6);

          // Update the links…
          const link = svg.selectAll('path.link')
              .data(links, d => d.target.id);

          // Enter any new links at the parent's previous position.
          const linkEnter = link.enter().insert('path', 'g')
              .attr('class', 'link')
              .attr('d', d => {
                  const o = { x: source.x0, y: source.y0 };
                  return diagonal(o, o);
              });

          // Transition links to their new position.
          link.merge(linkEnter).transition()
              .duration(750)
              .attr('d', d => diagonal(d.source, d.target));

          // Transition exiting nodes to the parent's new position.
          link.exit().transition()
              .duration(750)
              .attr('d', d => {
                  const o = { x: source.x, y: source.y };
                  return diagonal(o, o);
              })
              .remove();

          // Stash the old positions for transition.
          nodes.forEach(d => {
              d.x0 = d.x;
              d.y0 = d.y;
          });

          // Creates a curved (diagonal) path from parent to the child nodes
          function diagonal(s, d) {
              return `M${s.y},${s.x}
                      C${(s.y + d.y) / 2},${s.x}
                      ${(s.y + d.y) / 2},${d.x}
                      ${d.y},${d.x}`;
          }

          // Toggle children on click.
          function click(event, d) {
              if (d.children) {
                  d._children = d.children;
                  d.children = null;
              } else {
                  d.children = d._children;
                  d._children = null;
              }
              update(d);
          }
        }


    </script>
</body>
</html>
